#!/bin/sh
# post-checkout
#       This hook is invoked when a git checkout is run after having updated
#       the worktree. The hook is given three parameters: the ref of the
#       previous HEAD, the ref of the new HEAD (which may or may not have
#       changed), and a flag indicating whether the checkout was a branch
#       checkout (changing branches, flag=1) or a file checkout (retrieving a
#       file from the index, flag=0). This hook cannot affect the outcome of
#       git checkout.
#
#       It is also run after git clone, unless the --no-checkout (-n) option is
#       used. The first parameter given to the hook is the null-ref, the second
#       the ref of the new HEAD and the flag is always 1.
#
#       This hook can be used to perform repository validity checks,
#       auto-display differences from the previous HEAD if different, or set
#       working dir metadata properties.

PREV_HEAD="$1"
NEW_HEAD="$2"
BRANCH="$3"
[ -z "$GIT_DBG" ] || echo "post-checkout: argv: [$PREV_HEAD,$NEW_HEAD,$BRANCH]"

case "$(git config remote.origin.url)" in
    ?hg:*|hg:*|gitifyhg:*)          # mercurial repo (and my aliases)
        [ -z "$GIT_DBG" ] || echo "post-checkout: hg bridge"

        if [ "$(printf "%d" "0x$PREV_HEAD" 2>/dev/null)" -eq 0 ]; then	# it's a clone
            [ -z "$GIT_DBG" ] || echo "post-checkout: cloning..."
        fi

        if [ ! -f "$GIT_DIR/refs/notes/hg" ]; then
            # Set up notes ref for the mercurial commit hash
            if hg_ref_fl="$(ls "$GIT_DIR/refs/notes/hg-"* 2>&1)"; then
                hg_ref="${hg_ref_fl#$GIT_DIR/}"
                [ -z "$GIT_DBG" ] || echo "post-checkout: hg ref: $hg_ref"
                git symbolic-ref refs/notes/hg "$hg_ref"
                git config core.notesRef refs/notes/hg
                [ -z "$GIT_DBG" ] || echo "post-checkout: core.notesRef: $(
                                               git config core.notesRef)"
            else
                [ -z "$GIT_DBG" ] || echo "post-checkout: $hg_ref_fl"
            fi
        fi

        if [ -f .hgignore ] && [ $BRANCH -eq 1 ]; then  # branch checkout
            # (re)generate the .gitignore file
            [ -z "$GIT_DBG" ] || echo "post-checkout: generate .gitignore"
            sed <.hgignore >.gitignore -e '
                :regexp
                /^syntax:\s*glob/ { d; b glob }
                s/\([^\\]\)[()|?]\+/\1/g; s/TODO: proper group handling//;
                s/\([^\\]\){[0-9,]\+}/\1*/g; s/\\//g;
                s/^\^\(.*\)\$$/\1/; s/^\^\(.*\)/\1*/; s/\(.*\)\$$/*\1/;
                s/\([^\\]\)\.\*/\1*/g; s/\([^\\]\)\./\1?/g; s/\([^\\]\)+/\1*/g;
                n; b regexp

                :glob
                /^syntax:\s*regexp/ { d; b regexp }
                n; b glob
                '
            echo ".gitignore" >>.gitignore
        fi
        ;;
esac

exit 0  # cannot affect the outcome, so don't even try
